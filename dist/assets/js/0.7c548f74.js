(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{51:function(e,t,n){"use strict";n.r(t);var a=n(0),r=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"content"},[n("h1",{attrs:{id:"接口定义"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#接口定义","aria-hidden":"true"}},[e._v("#")]),e._v(" 接口定义")]),n("p",[e._v("工作中，少不了要定义各种接口，系统集成要定义接口，前后台掉调用也要定义接口。接口定义一定程度上能反应程序员的编程功底。列举一下工作中我发现大家容易出现的问题：")]),n("h1",{attrs:{id:"_1-返回格式不统一"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-返回格式不统一","aria-hidden":"true"}},[e._v("#")]),e._v(" 1. 返回格式不统一")]),n("p",[e._v("同一个接口，有时候返回数组，有时候返回单个；成功的时候返回对象，失败的时候返回错误信息字符串。工作中有个系统集成就是这样定义的接口，真是辣眼睛。这个对应代码上，返回的类型是map，json，object，都是不应该的。实际工作中，我们会定义一个统一的格式，就是ResultBean，分页的有另外一个PageResultBean")]),n("p",[e._v("错误范例：")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(' //返回map可读性不好，尽量不要\n  @PostMapping("/delete")\n  public Map<String, Object> delete(long id, String lang) {\n\n  }\n\n  // 成功返回boolean，失败返回string，大忌\n  @PostMapping("/delete")\n  public Object delete(long id, String lang) {\n    try {\n      boolean result = configService.delete(id, local);\n      return result;\n    } catch (Exception e) {\n      log.error(e);\n      return e.toString();\n    }\n  }\n')])]),n("h1",{attrs:{id:"_2-没有考虑失败情况"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-没有考虑失败情况","aria-hidden":"true"}},[e._v("#")]),e._v(" 2. 没有考虑失败情况")]),n("p",[e._v("一开始只考虑成功场景，等后面测试发现有错误情况，怎么办，改接口呗，前后台都改，劳民伤财无用功。")]),n("p",[e._v("错误范例：")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(' //不返回任何数据，没有考虑失败场景，容易返工\n　@PostMapping("/update")\n  public void update(long id, xxx) {\n\n  }\n')])]),n("p",[e._v("#3. 出现和业务无关的输入参数")]),n("p",[e._v("如lang语言，当前用户信息 都不应该出现参数里面，应该从当前会话里面获取。后面讲ThreadLocal会说到怎么样去掉。除了代码可读性不好问题外，尤其是参数出现当前用户信息的，这是个严重问题。")]),n("p",[e._v("错误范例：")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(' // （当前用户删除数据）参数出现lang和userid，尤其是userid，大忌\n　@PostMapping("/delete")\n  public Map<String, Object> delete(long id, String lang, String userId) {\n\n  }\n')])]),n("h1",{attrs:{id:"_4-出现复杂的输入参数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-出现复杂的输入参数","aria-hidden":"true"}},[e._v("#")]),e._v(" 4. 出现复杂的输入参数")]),n("p",[e._v("一般情况下，不允许出现例如json字符串这样的参数，这种参数可读性极差。应该定义对应的bean。")]),n("p",[e._v("错误范例：")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(' // 参数出现json格式，可读性不好，代码也难看\n　@PostMapping("/update")\n  public Map<String, Object> update(long id, String jsonStr) {\n\n  }\n')])]),n("h1",{attrs:{id:"_5-没有返回应该返回的数据"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-没有返回应该返回的数据","aria-hidden":"true"}},[e._v("#")]),e._v(" 5. 没有返回应该返回的数据")]),n("p",[e._v("例如，新增接口一般情况下应该返回新对象的id标识，这需要编程经验。新手定义的时候因为前台没有用就不返回数据或者只返回true，这都是不恰当的。别人要不要是别人的事情，你该返回的还是应该返回。")]),n("p",[e._v("错误范例：")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(' // 约定俗成，新建应该返回新对象的信息，只返回boolean容易导致返工\n　@PostMapping("/add")\n  public boolean add(xxx) {\n    //xxx\n    return configService.add();\n  }\n')])]),n("p",[e._v("很多人看了我的这篇文章 "),n("a",{attrs:{href:"https://www.imooc.com/article/27569",target:"_blank",rel:"noopener noreferrer"}},[e._v("程序员你为什么这么累？")]),e._v("，都觉得里面的技术也很简单，没有什么特别的地方，但是，实现这个代码框架之前，就是要你的接口的统一的格式ResultBean，aop才好做。有些人误解了，我那篇文章说的都不是技术，重点说的是编码习惯工作方式，如果你重点还是放在什么技术上，那我也帮不了你了。同样，如果我后面的关于习惯和规范的帖子，你重点还是放在技术上的话，那是丢了西瓜捡芝麻，有很多贴还是没有任何技术点呢。")]),n("p",[e._v("附上ResultBean，没有任何技术含量：(使用了lombok)")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('@Data\npublic class ResultBean<T> implements Serializable {\n\n  private static final long serialVersionUID = 1L;\n\n  public static final int SUCCESS = 0;\n\n  public static final int FAIL = 1;\n\n  public static final int NO_PERMISSION = 2;\n\n  private String msg = "success";\n\n  private int code = SUCCESS;\n\n  private T data;\n\n  public ResultBean() {\n    super();\n  }\n\n  public ResultBean(T data) {\n    super();\n    this.data = data;\n  }\n\n  public ResultBean(Throwable e) {\n    super();\n    this.msg = e.toString();\n    this.code = FAIL ;\n  }\n}\n')])]),n("p",[n("strong",[e._v("统一的接口规范，能帮忙规避很多无用的返工修改和可能出现的问题。能使代码可读性更加好，利于进行aop和自动化测试这些额外工作。大家一定要重视。")])]),n("p",[e._v("下一篇讲controller的规范，还有用到ResultBean，敬请留意。觉得有用请点赞加关注")]),n("h1",{attrs:{id:"github地址"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#github地址","aria-hidden":"true"}},[e._v("#")]),e._v(" ===========GITHUB地址===========")]),n("p",[e._v("所有的代码细节都在已经上了github了，地址 "),n("a",{attrs:{href:"https://github.com/xwjie/PLMCodeTemplate",target:"_blank",rel:"noopener noreferrer"}},[e._v("xwjie/PLMCodeTemplate")]),e._v("，欢迎加星。有问题欢迎提出。")])])}],!1,null,null,null);t.default=r.exports}}]);